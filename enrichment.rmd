---
title: "Enrichment Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)
```


```{r Source R functions, message=FALSE, warning=FALSE, include=FALSE}

source("R_functions/utils.R", local = knitr::knit_global())
source("R_functions/read_data.R", local = knitr::knit_global())

```


## GSEA

```{r FGSEA table, echo=FALSE, fig.height=10, fig.width=10, message=FALSE, warning=FALSE, paged.print=FALSE}

GSEA <- GSEA_plots(pathways = "Hallmark", Plot_title, Control, Test, res =  paste0(results_dir, "deseq2_results_annotated.tsv"))

GSEA[[1]]

```

```{r FGSEA plots, echo=FALSE, fig.height=10, fig.width=10, message=FALSE, warning=FALSE, paged.print=FALSE}

GSEA[[2]]

```

# GO Seq

```{r GO seq, fig.height=10, fig.width=8, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}

GoSeq <- 
  ORA_GoSeq(title = Plot_title, 
          control =  Control, 
          test =  Test,
          FC = FC_ORA,
          pvalue = pvalue_ORA,
          #res = DeSeq2_results[["res"]],
          #res = "results/deseq2_results_annotated.tsv"
  
  
)


```


```{r GoSeq_plot, echo=FALSE, fig.height=10, fig.width=8, message=FALSE, warning=FALSE, paged.print=FALSE}
GoSeq
```


```{r clusterProfiler, fig.height=15, fig.width=8, message=FALSE, warning=FALSE, include=FALSE, paged.print=TRUE}
invisible(gc())
clusterProfiler_Plots <- clusterProfiler_Plots(
  res = paste0(results_dir, "deseq2_results_annotated.tsv"),
  title = Plot_title)

```

```{r clusterProfiler_Plots, fig.height=7, fig.width=7}
clusterProfiler_Plots
```


```{r enrichR, include=FALSE}

#invisible(gc())
setEnrichrSite("Enrichr") # Human genes
dbs <- listEnrichrDbs()
dbs <- c("GO_Biological_Process_2021",
         "GO_Cellular_Component_2021",
         "GO_Molecular_Function_2021",
         "Reactome_2022")

res <- paste0(results_dir, "deseq2_results_annotated.tsv")
results_annotated <- read.delim(res)

universe <- results_annotated %>% pull(hgnc_symbol)
UpSigGenes <- results_annotated %>%
    dplyr::filter(padj < 0.05, log2FoldChange > 1
                  #!is.na(ENSEMBL)
    ) %>% pull(hgnc_symbol)
DownSigGenes <- results_annotated %>%
    dplyr::filter(padj < 0.05, log2FoldChange < -1
                  #!is.na(ENSEMBL)
    ) %>% pull(hgnc_symbol)


UPenriched <- enrichr(UpSigGenes, dbs)
DOWNenriched <- enrichr(DownSigGenes, dbs) 

enrichR_plot <- list()
for (i in 1:4) {
  enrichR_plot[[i]] <- plotEnrich(UPenriched[[i]], showTerms = 5, numChar = 40, y = "Count", orderBy = "Combined.Score")
  enrichR_plot[[i+4]] <- plotEnrich(DOWNenriched[[i]], showTerms = 5, numChar = 100, y = "Count", orderBy = "Combined.Score")
}




```

##Upregulated Pathways
```{r enricher plots, fig.height=5, fig.width=7}


for (i in 1:4) {
  enrichR_plot[[i]] <- enrichR_plot[[i]] + scale_x_discrete(label = function(x) str_wrap(x, width = 10))
  print(enrichR_plot[[i]])
}

```


##Downregulated Pathway


```{r enricher plots2, fig.height=5, fig.width=7, message=FALSE, warning=FALSE}

for (i in 1:4) {
  enrichR_plot[[i+4]] <- enrichR_plot[[i+4]] + scale_x_discrete(label = function(x) str_wrap(x, width = 10))
  print(enrichR_plot[[i+4]])
}

```



```{r DAVID, eval=FALSE, include=FALSE}
#BiocManager::install("RDAVIDWebService")

# ## try http:// if https:// URLs are not supported
# source("https://bioconductor.org/biocLite.R")
# biocLite("RDAVIDWebService")
# #install.packages("RDAVIDWebService")
# library(clusterProfiler)
# # devtools::install_github("XiaoFei-Zhao/RDAVIDWebService")
# library(RDAVIDWebService)
# res <- paste0(results_dir, "deseq2_results_annotated.tsv")
# results_annotated <- read.delim(res)
# universe <- results_annotated %>% pull(ENTREZID)
# sigGenes <- results_annotated %>%
#   dplyr::filter(padj < 0.05,
#                 abs(log2FoldChange) > 1
#                   #!is.na(ENSEMBL)
#     ) %>% pull(ENTREZID)
# 
# david = enrichDAVID(gene = sigGenes, idType="ENTREZ_GENE_ID",
#                     universe = universe, annotation="KEGG_PATHWAY")

```


## Aleternative GSE and ORA



```{r ananlysis_Pi, fig.height=7, fig.width=7, message=FALSE, warning=FALSE}

print("Upregulated genes")

xgr_data <- results_annotated %>% dplyr::filter(padj < 0.05, abs(log2FoldChange) > 1)


data <- xgr_data %>% 
  dplyr::filter(!is.na(hgnc_symbol) & !duplicated(hgnc_symbol))%>%
  dplyr::pull(hgnc_symbol)
background <- results_annotated %>% 
  dplyr::filter(!is.na(hgnc_symbol) & !duplicated(hgnc_symbol)) %>%
  dplyr::pull(hgnc_symbol)
ontology <- c("KEGG" = "MsigdbC2KEGG", "Reactome" = "MsigdbC2REACTOME", "DO" = "DO")


eTerm <- xEnricherGenes(data=data, background=background, ontology= ontology[2])

eTerm_concise <- xEnrichConciser(eTerm)


bp <- xEnrichBarplot(eTerm, top_num=10, displayBy="adjp")

# bp <- ggpar(bp, 
#             font.x = 2,
#             xlab = )

bp <- bp + scale_x_discrete(labels = function(x) str_wrap(x, width = 40)) 
bp


print("DOWN regulated genes")

xgr_data <- results_annotated %>% dplyr::filter(padj < 0.05, abs(log2FoldChange) < -1)


data <- xgr_data %>% 
  dplyr::filter(!is.na(hgnc_symbol) & !duplicated(hgnc_symbol))%>%
  dplyr::pull(hgnc_symbol)
background <- results_annotated %>% 
  dplyr::filter(!is.na(hgnc_symbol) & !duplicated(hgnc_symbol)) %>%
  dplyr::pull(hgnc_symbol)
ontology <- c("KEGG" = "MsigdbC2KEGG", "Reactome" = "MsigdbC2REACTOME", "DO" = "DO")


eTerm <- xEnricherGenes(data=data, background=background, ontology= ontology[2])

eTerm_concise <- xEnrichConciser(eTerm)


bp <- xEnrichBarplot(eTerm, top_num=10, displayBy="adjp")

# bp <- ggpar(bp, 
#             font.x = 2,
#             xlab = )

bp <- bp + scale_x_discrete(labels = function(x) str_wrap(x, width = 40)) 
bp
#ggsave(paste0(plots_dir, Plot_title,"_XGR.png"))

```



```{r xgr, fig.height=7, fig.width=7}
#xDefineOntology

## below works tuned off for now. Review later.
# xEnrichDAGplot(eTerm, top_num="auto", displayBy="fdr", node.info=c("both"), graph.node.attrs=list(fontsize=30), newpage=F)
# 
# RData.location <- "http://galahad.well.ox.ac.uk/bigdata"
# network_input <- results_annotated %>%
#   dplyr::filter(!is.na(hgnc_symbol),
#                 !duplicated(hgnc_symbol),
#                 log2FoldChange < -1) %>%
#   dplyr::select(hgnc_symbol, padj)
# 
# subg_func <- xSubneterGenes(data=network_input, network="STRING_low", subnet.size=75, RData.location=RData.location)
# subg <- subg_func
# pattern <- -log10(as.numeric(V(subg)$significance))
# xVisNet(g=subg, pattern=pattern, vertex.shape="sphere", vertex.label.font=2, newpage=F)


RData.location <- "http://galahad.well.ox.ac.uk/bigdata"

#### xPier test ####

xgr_data_up <- results_annotated %>% 
  dplyr::filter(padj < 0.05, log2FoldChange > 1)
xgr_data_down <- results_annotated %>% 
  dplyr::filter(padj < 0.05, log2FoldChange < -1)



xgr_ranks <- xgr_data_up %>% 
  dplyr::filter(!is.na(hgnc_symbol), !duplicated(hgnc_symbol)) %>%
  dplyr::select(hgnc_symbol, stat) %>% mutate(rank = dense_rank(-stat)) %>% dplyr::select(-stat) %>% mutate(rank = rank/nrow(.))

xgr_ranks <- xgr_data_down %>% 
  dplyr::filter(!is.na(hgnc_symbol), !duplicated(hgnc_symbol)) %>%
  dplyr::select(hgnc_symbol, stat) %>% mutate(rank = dense_rank(-stat)) %>% dplyr::select(-stat) %>% mutate(rank = rank/nrow(.))  
  
  
pNode <- xPierGenes(xgr_ranks, network = "STRING_high", restart=0.7)


##How does this work???
xPGSEA <- xPierGSEA(pNode, ontology = "MsigdbC2REACTOME")

eTerm <- xPierPathways(pNode, priority.top=100, ontology="MsigdbC2REACTOME", RData.location=RData.location)
eTerm_nonred <- xEnrichConciser(eTerm)

# view the top pathways/terms
xEnrichViewer(eTerm_nonred) %>% kableExtra::kable()


bp <- xEnrichBarplot(eTerm_nonred, top_num="auto", displayBy="fdr", FDR.cutoff=1e-3, wrap.width=50, signature=FALSE)
bp

ggsave(paste0(plots_dir, Plot_title,"_XGR_Pi.png"))
```


## TF ANALYSIS

```{r chea3}
# library(httr)
# library(jsonlite)

UpSigGenes <- results_annotated %>%
  drop_na() %>%
  dplyr::filter(padj < 0.05, log2FoldChange > 1
                  #!is.na(ENSEMBL)
    ) %>% pull(hgnc_symbol)


DownSigGenes <- results_annotated %>%
  drop_na() %>%
  dplyr::filter(padj < 0.05, log2FoldChange < -1
                  #!is.na(ENSEMBL)
    ) %>% pull(hgnc_symbol)

url = "https://maayanlab.cloud/chea3/api/enrich/"
encode = "json"
query_name <- paste(Plot_title, Control, "vs", Test, "Upregulated", sep = "_")
payload = list(query_name = query_name, gene_set = UpSigGenes)

#POST to ChEA3 server
response = POST(url = url, body = payload, encode = encode)
json = content(response, "text")

#write.table(sigGenes, "C:\\Users\\asrinivasan\\Desktop\\sigGenes.txt", row.names = FALSE, col.names = FALSE, sep = ",", quote = FALSE)

#results as list of R dataframes
chea3_results_upregulated = fromJSON(json)


#####
query_name <- paste(Plot_title, Control, "vs", Test, "Downregulated", sep = "_")
payload = list(query_name = query_name, gene_set = DownSigGenes)

#POST to ChEA3 server
response = POST(url = url, body = payload, encode = encode)
json = content(response, "text")

#write.table(sigGenes, "C:\\Users\\asrinivasan\\Desktop\\sigGenes.txt", row.names = FALSE, col.names = FALSE, sep = ",", quote = FALSE)

#results as list of R dataframes
chea3_results_downregulated = fromJSON(json)



```



```{r decoupleR_TF}
#BiocManager::install("OmnipathR")
#BiocManager::install("remotes")
#BiocManager::install("dorothea")
invisible(gc())

# library("dorothea")
# library("decoupleR")

dorothea_df <- dorothea_hs %>%
  dplyr::filter(confidence %in% c("A", "B", "C")) %>%
  dplyr::select(source = tf, confidence, target, mor) %>%
  as.data.frame() %>%
  mutate(weight = mor/match(confidence, LETTERS))

decoupleR_mat <- 
  DeSeq2_return$vsd %>%
  assay() %>% as.data.frame() %>% 
  rownames_to_column("GeneID") %>%
  mutate(
    hgnc_symbol = mapIds(EnsDb.Hsapiens.v86, keys = GeneID, keytype = "GENEID", column = "SYMBOL"), .before = 1) %>%
   drop_na() %>%
  select(-2) %>%
  column_to_rownames("hgnc_symbol") %>% as.matrix()

## if annotating is done after results from deseq
# decoupleR_mat <-
#   DeSeq2_return$vsd %>% 
#   assay() %>% 
#   as.data.frame() %>% 
#   rownames_to_column("ensembl_gene_id") %>% 
#   left_join(results_annotated %>% dplyr::select(ensembl_gene_id, hgnc_symbol) %>% unique()) %>% dplyr::select(-ensembl_gene_id) %>% distinct(hgnc_symbol, .keep_all = TRUE) %>% drop_na() %>% column_to_rownames("hgnc_symbol") %>% as.matrix()

#decoupleR_net <- get_progeny(organism = 'human', top = 300)
#decoupleR_net <- get_dorothea(organism='human', levels=c('A', 'B', 'C'))

sample_acts <- run_wmean(mat=decoupleR_mat, 
                         net=dorothea_df, 
                         .source='source', 
                         .target='target',
                  .mor='weight', 
                  times = 100, 
                  minsize = 5)

### number of tfs for heatmap
n_tfs <- 25

# Transform to wide matrix
sample_acts_mat <- sample_acts %>%
  filter(statistic == 'norm_wmean') %>%
  pivot_wider(id_cols = 'condition', names_from = 'source',
              values_from = 'score') %>%
  column_to_rownames('condition') %>%
  as.matrix()

# Get top tfs with more variable means across clusters
tfs <- sample_acts %>%
  group_by(source) %>%
  summarise(std = sd(score)) %>%
  arrange(-abs(std)) %>%
  head(n_tfs) %>%
  pull(source)


sample_acts_mat <- sample_acts_mat[,tfs]

# Scale per sample
sample_acts_mat <- scale(sample_acts_mat)

# Choose color palette
palette_length = 100
my_color = colorRampPalette(c("Darkblue", "white","red"))(palette_length)

my_breaks <- c(seq(-3, 0, length.out=ceiling(palette_length/2) + 1),
               seq(0.05, 3, length.out=floor(palette_length/2)))


# Plot
pheatmap(sample_acts_mat, border_color = NA, color=my_color, breaks = my_breaks) 

```



```{r decoupleR_TF_Degs}
# Extract t-values per gene

decoupleR_deg <- results_annotated %>% 
  dplyr::select(hgnc_symbol, stat, log2FoldChange, padj) %>% 
  distinct(hgnc_symbol, .keep_all = TRUE) %>% 
  drop_na() %>% 
  column_to_rownames("hgnc_symbol") %>% 
  as.matrix()

contrast_acts <- run_wmean(
  mat = decoupleR_deg[, "stat"],
  net = dorothea_df,
  .source = 'source',
  .target = 'target',
  .mor = 'weight',
  times = 100,
  minsize = 5
)
# Filter norm_wmean
f_contrast_acts <- contrast_acts %>%
  filter(statistic == 'norm_wmean')


# Filter norm_wmean
f_contrast_acts <- contrast_acts %>%
  filter(statistic == 'norm_wmean') %>%
  mutate(rnk = NA)

# Filter top TFs in both signs
msk <- f_contrast_acts$score > 0
f_contrast_acts[msk, 'rnk'] <- rank(-f_contrast_acts[msk, 'score'])
f_contrast_acts[!msk, 'rnk'] <- rank(-abs(f_contrast_acts[!msk, 'score']))
tfs <- f_contrast_acts %>%
  arrange(rnk) %>%
  head(n_tfs) %>%
  pull(source)
f_contrast_acts <- f_contrast_acts %>%
  filter(source %in% tfs)

# Plot
ggplot(f_contrast_acts, aes(x = reorder(source, score), y = score)) + 
    geom_bar(aes(fill = score), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")

#######

decoupleR_vis_TF <- function(tf = NULL,
                             
                             net = dorothea_df, 
                             deg = decoupleR_deg) {
  tf <- f_contrast_acts %>% 
  filter(rnk == 1, 
         score == max(score)) %>% 
  pull(source)
  
  df <- net %>%
    filter(source == tf) %>%
    arrange(target) %>%
    mutate(ID = target, color = "3") %>%
    column_to_rownames('target')
  
  inter <- sort(intersect(rownames(deg), rownames(df)))
  df <- df[inter,]
  df[, c('stat', 'log2FoldChange', 'padj')] <- deg[inter,]
  df <- df %>%
    mutate(color = if_else(mor > 0 & stat > 0, '1', color)) %>%
    mutate(color = if_else(mor > 0 & stat < 0, '2', color)) %>%
    mutate(color = if_else(mor < 0 & stat > 0, '2', color)) %>%
    mutate(color = if_else(mor < 0 & stat < 0, '1', color))
  
  plot <-
    ggplot(df, aes(
    x = log2FoldChange,
    y = -log10(padj),
    color = color,
    size = abs(weight)
  )) +
    geom_point() +
    scale_colour_manual(values = c("red", "royalblue3", "grey")) +
    geom_label_repel(aes(label = ID, size = 1)) +
    theme_minimal() +
    theme(legend.position = "none") +
    geom_vline(xintercept = 0, linetype = 'dotted') +
    geom_hline(yintercept = 0, linetype = 'dotted') +
    ggtitle(tf)
  
  return(plot)
  
}


decoupleR_vis_TF()
```




```{r decoupleR_PROGENy, echo=FALSE, message=FALSE, warning=FALSE}
#BiocManager::install("OmnipathR")
#BiocManager::install("remotes")
#BiocManager::install("dorothea")
invisible(gc())


PROGENy_df <-get_progeny(organism = 'human', top = 500)

decoupleR_mat <- 
  DeSeq2_return$vsd %>%
  assay() %>% as.data.frame() %>% 
  rownames_to_column("GeneID") %>%
  mutate(
    hgnc_symbol = mapIds(EnsDb.Hsapiens.v86, keys = GeneID, keytype = "GENEID", column = "SYMBOL"), .before = 1) %>%
   drop_na() %>%
  select(-2) %>%
  column_to_rownames("hgnc_symbol") %>% as.matrix()

## if annotating is done after results from deseq
# decoupleR_mat <-
#   DeSeq2_return$vsd %>% 
#   assay() %>% 
#   as.data.frame() %>% 
#   rownames_to_column("ensembl_gene_id") %>% 
#   left_join(results_annotated %>% dplyr::select(ensembl_gene_id, hgnc_symbol) %>% unique()) %>% dplyr::select(-ensembl_gene_id) %>% distinct(hgnc_symbol, .keep_all = TRUE) %>% drop_na() %>% column_to_rownames("hgnc_symbol") %>% as.matrix()

decoupleR_net <- get_progeny(organism = 'human', top = 500)
#decoupleR_net <- get_dorothea(organism='human', levels=c('A', 'B', 'C'))

sample_acts <- run_wmean(mat=decoupleR_mat, 
                         net=decoupleR_net, 
                         .source='source', 
                         .target='target',
                  .mor='weight', 
                  times = 100, 
                  minsize = 5)

### number of tfs for heatmap
n_tfs <- 25

# Transform to wide matrix
sample_acts_mat <- sample_acts %>%
  filter(statistic == 'norm_wmean') %>%
  pivot_wider(id_cols = 'condition', names_from = 'source',
              values_from = 'score') %>%
  column_to_rownames('condition') %>%
  as.matrix()

# Get top tfs with more variable means across clusters
tfs <- sample_acts %>%
  group_by(source) %>%
  summarise(std = sd(score)) %>%
  arrange(-abs(std)) %>%
  head(n_tfs) %>%
  pull(source)


sample_acts_mat <- sample_acts_mat[,tfs]

# Scale per sample
sample_acts_mat <- scale(sample_acts_mat)

# Choose color palette
palette_length = 100
my_color = colorRampPalette(c("Darkblue", "white","red"))(palette_length)

my_breaks <- c(seq(-3, 0, length.out=ceiling(palette_length/2) + 1),
               seq(0.05, 3, length.out=floor(palette_length/2)))


# Plot
pheatmap(sample_acts_mat, border_color = NA, color=my_color, breaks = my_breaks) 

```



```{r decoupleR_PROGENy_Degs, echo=FALSE, message=FALSE, warning=FALSE}
# Extract t-values per gene

decoupleR_deg <- results_annotated %>% 
  dplyr::select(hgnc_symbol, stat, log2FoldChange, padj) %>% 
  distinct(hgnc_symbol, .keep_all = TRUE) %>% 
  drop_na() %>% 
  column_to_rownames("hgnc_symbol") %>% 
  as.matrix()

contrast_acts <- run_wmean(
  mat = decoupleR_deg[, "stat"],
  net = decoupleR_net,
  .source = 'source',
  .target = 'target',
  .mor = 'weight',
  times = 100,
  minsize = 5
)
# Filter norm_wmean
f_contrast_acts <- contrast_acts %>%
  filter(statistic == 'norm_wmean')


# Filter norm_wmean
f_contrast_acts <- contrast_acts %>%
  filter(statistic == 'norm_wmean') %>%
  mutate(rnk = NA)

# Filter top TFs in both signs
msk <- f_contrast_acts$score > 0
f_contrast_acts[msk, 'rnk'] <- rank(-f_contrast_acts[msk, 'score'])
f_contrast_acts[!msk, 'rnk'] <- rank(-abs(f_contrast_acts[!msk, 'score']))
tfs <- f_contrast_acts %>%
  arrange(rnk) %>%
  head(n_tfs) %>%
  pull(source)
f_contrast_acts <- f_contrast_acts %>%
  filter(source %in% tfs)

# Plot
ggplot(f_contrast_acts, aes(x = reorder(source, score), y = score)) + 
    geom_bar(aes(fill = score), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")


#######

decoupleR_vis_TF <- function(tf = NULL,
                             
                             net = dorothea_df, 
                             deg = decoupleR_deg) {
  tf <- f_contrast_acts %>% 
  filter(rnk == 1, 
         score == min(score)) %>% 
  pull(source)
  
  df <- net %>%
    filter(source == tf) %>%
    arrange(target) %>%
    mutate(ID = target, color = "3") %>%
    column_to_rownames('target')
  
  inter <- sort(intersect(rownames(deg), rownames(df)))
  df <- df[inter,]
  df[, c('stat', 'log2FoldChange', 'padj')] <- deg[inter,]
  df <- df %>%
    mutate(color = if_else(weight > 0 & stat > 0, '1', color)) %>%
    mutate(color = if_else(weight > 0 & stat < 0, '2', color)) %>%
    mutate(color = if_else(weight < 0 & stat > 0, '2', color)) %>%
    mutate(color = if_else(weight < 0 & stat < 0, '1', color))
  
  plot <-
    ggplot(df, aes(
    x = log2FoldChange,
    y = -log10(padj),
    color = color,
    size = abs(weight)
  )) +
    geom_point() +
    scale_colour_manual(values = c("red", "royalblue3", "grey")) +
    geom_label_repel(aes(label = ID, size = 1)) +
    theme_minimal() +
    theme(legend.position = "none") +
    geom_vline(xintercept = 0, linetype = 'dotted') +
    geom_hline(yintercept = 0, linetype = 'dotted') +
    ggtitle(tf)
  
  return(plot)
  
}


decoupleR_vis_TF(net = decoupleR_net)
```



```{r TFEA.ChIP}
#BiocManager::install("TFEA.ChIP")
invisible(gc())
#library(TFEA.ChIP)
TFEA_ChIP_input_raw <- preprocessInputData( DeSeq2_return$res )

#extract vector with names of upregulated genes
Genes.Upreg <- Select_genes( TFEA_ChIP_input_raw, min_LFC = 1 )
#extract vector with names of downregulated genes
Genes.Downreg <- Select_genes( TFEA_ChIP_input_raw, max_LFC = -1 )
#extract vector with names of non-responsive genes
Genes.Control <- Select_genes( TFEA_ChIP_input_raw,
    min_pval = 0.05, max_pval = 1,
    min_LFC = -0.25, max_LFC = 0.25 )

CM_list_UP <- contingency_matrix( Genes.Upreg, Genes.Control ) #generates list of contingency tables, one per dataset
pval_mat_UP <- getCMstats( CM_list_UP ) #generates list of p-values and OR from association test


CM_list_DOWN <- contingency_matrix( Genes.Downreg, Genes.Control ) #generates list of contingency tables, one per dataset
pval_mat_DOWN <- getCMstats( CM_list_DOWN ) #generates list of p-values and OR from association test

print("Upregulated TFs")
TF_ranking <- rankTFs( pval_mat_UP, rankMethod = "gsea", makePlot = TRUE )

TF_ranking <- rankTFs( pval_mat_UP, rankMethod = "wilcoxon", makePlot = TRUE )
TF_ranking[[ "TFranking_plot" ]]


TF_ranking <- rankTFs( pval_mat_DOWN, rankMethod = "gsea", makePlot = TRUE )

print("Downregulated TFs")
TF_ranking <- rankTFs( pval_mat_DOWN, rankMethod = "wilcoxon", makePlot = TRUE )
TF_ranking[[ "TFranking_plot" ]]


HS_HALLMARK <- msigdbr(species = "Homo sapiens", category = "H")
HS_HALLMARK <- split(x = HS_HALLMARK$gene_symbol, f = HS_HALLMARK$gs_name)
HS_CP_REACTOME <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:REACTOME")
HS_CP_REACTOME <- split(x = HS_CP_REACTOME$gene_symbol, f = HS_CP_REACTOME$gs_name)


print("NFkB pathways related TFs")
specialTF <-
  dorothea_df %>% 
  filter(source %in% HS_CP_REACTOME$REACTOME_NF_KB_IS_ACTIVATED_AND_SIGNALS_SURVIVAL
) %>% pull(source)

# specialTF <-
#   decoupleR_net %>% 
#   filter(source == "Hypoxia",
#          target %in% dorothea_df$source) %>% 
#   pull(target) #%>% unique()

names(specialTF) <- specialTF


print("Downregulated")
plot_CM( pval_mat_DOWN, 
         specialTF = specialTF, 
         TF_colors = c(rep("red", length(specialTF))) ) #plot p-values against ORs


print("Upregulated")

plot_CM( pval_mat_UP, 
         specialTF = specialTF, 
         TF_colors = c(rep("red", length(specialTF))) ) #plot p-values against ORs


```



```{r CeTF _not_run, eval=FALSE, include=FALSE}
# Loading packages
library(CeTF)

# Loading dds data as an RSE object

CeTF_input <- DeSeq2_return$dds %>% as("RangedSummarizedExperiment")

# SummarizedExperiment::SummarizedExperiment(
#   assays = assay(DeSeq2_return$dds),
#   rowData = rowData(DeSeq2_return$dds),
#   colData = colData
# ) 

# Creating a variable with annotation data
anno <- as.data.frame(colData(CeTF_input))
anno <- anno[order(CeTF_input[[deseq2_design_condition]], decreasing = TRUE), ]
anno <- data.frame(cond = CeTF_input[[deseq2_design_condition]], 
                   row.names = rownames(anno))
# Creating a variable with count data
counts <- assay(CeTF_input)

# Sorting count data samples by conditions (untrt and trt)
counts <- counts[, order(CeTF_input[[deseq2_design_condition]], decreasing = TRUE)]

# Loading the Transcript Factors (TFs) character
data("TFs", package = "CeTF")



# Sorting count data samples by conditions (untrt and trt)
counts <- counts[, rownames(anno)]
colnames(counts) <- paste0(colnames(counts), c(rep(paste0("_",Test), 3), rep(paste0("_", Control), 3)))

# Differential Expression analysis to use only informative genes
DEGenes <- expDiff(exp = counts,
                   anno = anno,
                   conditions = c(Test, Control),
                   lfc = FC_VP,
                   padj = 0.05, 
                   diffMethod = "Reverter")

# Selecting only DE genes from counts data
counts <- counts[rownames(DEGenes$DE_unique), ]

# Converting count data to TPM
tpm <- apply(counts, 2, function(x) {
            (1e+06 * x)/sum(x)
        })

# Count normalization
Clean_Dat <- normExp(tpm)

# Loading the Transcript Factors (TFs) character
data("TFs")

# Verifying which TFs are in the subsetted normalized data
TFs <- rownames(Clean_Dat)[rownames(Clean_Dat) %in% TFs]

# Selecting the Target genes
Target <- setdiff(rownames(Clean_Dat), TFs)

# Ordering rows of normalized count data
RIF_input <- Clean_Dat[c(Target, TFs), ]

# Performing RIF analysis
RIF_out <- RIF(input = RIF_input,
               nta = length(Target),
               ntf = length(TFs),
               nSamples1 = 3,
               nSamples2 = 3)

# Printing first 10 rows
kable(RIF_out[1:10, ]) %>% 
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

# Performing the complete analysis
CeTF_out <- runAnalysis(mat = counts, 
                   conditions=c(Test, Control),
                   lfc = 5,
                   padj = 0.05,
                   TFs = TFs,
                   nSamples1 = 3,
                   nSamples2= 3,
                   tolType = "mean",
                   diffMethod = "Reverter", 
                   data.type = "counts")


CeTF_out


a <- function () {
  library(airway)
library(kableExtra)
library(knitr)

# Loading airway data
data("airway")

# Creating a variable with annotation data
anno <- as.data.frame(colData(airway))
anno <- anno[order(anno$dex, decreasing = TRUE), ]
anno <- data.frame(cond = anno$dex, 
                   row.names = rownames(anno))

# Creating a variable with count data
counts <- assay(airway)

# Sorting count data samples by conditions (untrt and trt)
counts <- counts[, rownames(anno)]
colnames(counts) <- paste0(colnames(counts), c(rep("_untrt", 4), rep("_trt", 4)))

  
return(counts)  
}

CeTF_counts <- a()
anno <- as.data.frame(colData(airway))
anno <- anno[order(anno$dex, decreasing = TRUE), ]
```


```{r cetf}

# Creating a variable with annotation data
CeTF_anno <- as.data.frame(colData(DeSeq2_return$dds)) 



# Creating a variable with count data
CeTF_counts <- assay(DeSeq2_return$dds) %>% 
  as.data.frame() %>% 
  rownames_to_column("id") %>% 
   mutate(
      hgnc_symbol = mapIds(
        EnsDb.Hsapiens.v86,
        keys = id,
        #keytype = "SYMBOL",
        #column = "GENEID"
        keytype = "GENEID",
        column = "SYMBOL"
      ),
      .before = 1
    ) %>%
    drop_na() %>%
    dplyr::select(-id) %>%
  column_to_rownames("hgnc_symbol") %>% 
  as.matrix()

# Sorting count data samples by conditions (untrt and trt) - this is not needed as deseq2 has already arranged Treatment column of colData as factor with two levels, Control/WT is level 1. 
CeTF_input <- CeTF_counts[, order(CeTF_anno[[deseq2_design_condition]])]

# Loading the Transcript Factors (TFs) character
data("TFs")
CeTF_TFs <- TFs %>%
  mapIds(
        EnsDb.Hsapiens.v86,
        keys = .,
        #keytype = "SYMBOL",
        #column = "GENEID"
        keytype = "GENEID",
        column = "SYMBOL"
      ) %>% unique()

TFs <- read.csv("TFDB.csv") %>%
  dplyr::filter(Is.TF. == "Yes") %>%
  filter(HGNC.symbol %in% CeTF_TFs) %>% 
  pull(HGNC.symbol)

# Performing the complete analysis
CeTF_out <- runAnalysis(mat = CeTF_input, 
                   conditions=c(Control, Test),
                   lfc = 1,
                   padj = 0.01,
                   TFs = TFs,
                   nSamples1 = CeTF_anno[[deseq2_design_condition]] %>% str_count(Control) %>% sum(),
                   nSamples2= CeTF_anno[[deseq2_design_condition]] %>% str_count(Test) %>% sum(),
                   tolType = "mean",
                   diffMethod = "DESeq2", #"Reverter", 
                   data.type = "counts")


# Using the runAnalysis output (CeTF class object)
SmearPlot(object = CeTF_out, 
          diffMethod = 'DESeq2', #"Reverter", 
          lfc = 1, 
          conditions = c(Control, Test), 
          type = "DE")


netConditionsPlot(CeTF_out)

# Accessing the network for condition 1
genes <- unique(c(as.character(NetworkData(CeTF_out, "network1")[, "gene1"]), 
                  as.character(NetworkData(CeTF_out, "network1")[, "gene2"])))

# Performing getGroupGO analysis
cond1 <- getGroupGO(genes = genes, 
                    ont = "BP", 
                    keyType = "SYMBOL", 
                    annoPkg = org.Hs.eg.db, 
                    level = 3)


# Performing getEnrich analysis
enrich <- getEnrich(genes = genes, organismDB = org.Hs.eg.db, 
                    keyType = 'SYMBOL', ont = 'BP', fdrMethod = "BH", 
                    fdrThr = 0.05, minGSSize = 5, maxGSSize = 500)


# Subsetting only the first 12 Ontologies with more counts
t1 <- head(cond1$results, 12)

# Subsetting the network for the conditions to make available only the 12 nodes subsetted
t2 <- subset(cond1$netGO, cond1$netGO$gene1 %in% as.character(t1[, "ID"]))

# generating the GO plot grouping by pathways
pt <- netGOTFPlot(netCond = NetworkData(CeTF_out, "network1") %>% 
                    mutate(across(everything(), as.character)),
                  resultsGO = t1,
                  netGO = t2,
                  anno = NetworkData(CeTF_out, "annotation"),
                  groupBy = 'pathways',
                  type = 'GO')
pt$plot


enrichPlot(res = enrich$results,
           type = "bar")
```

```{r}



# Using the runAnalysis output (CeTF class object)
choose_Tf_for_cetf <- function(tf){
SmearPlot(object = CeTF_out,
          diffMethod = 'Reverter',
          lfc = 1,
          conditions = c(Control, Test),
          TF = tf,
          label = TRUE, 
          type = "TF")
}

cetf_Tf_sucess <- c()
for (i in 1:length(TFs)) {

  skip_to_next <- FALSE

  # Note that print(b) fails since b doesn't exist

  tryCatch(choose_Tf_for_cetf(TFs[i]), error = function(e) { 
    #message("Error ", i)
    skip_to_next <<- TRUE})

  if(skip_to_next) {next} else 
         {cetf_Tf_sucess <- c(cetf_Tf_sucess, TFs[i])}    
}


#netConditionsPlot(CeTF_out)



#OutputData(CeTF_out, analysis = "rif", type = "tab")

```


```{r RcisTarget}
## Generates set of motifs based on GeneSets - can use either modules from WGCNA or DEGs

invisible(gc())
# library(RcisTarget)
# library(RcisTarget.hg19.motifDBs.cisbpOnly.500bp)

# Rankings
data(hg19_500bpUpstream_motifRanking_cispbOnly)


# Load gene sets to analyze. e.g.:
hypoxiaGeneSet <- read.table(file.path(system.file('examples', package='RcisTarget'), "hypoxiaGeneSet.txt"), stringsAsFactors=FALSE)[,1]


RcisT_geneLists <- list(CarUp = UpSigGenes, CarDown = DownSigGenes)

# Select motif database to use (i.e. organism and distance around TSS)
data(motifAnnotations_hgnc)

# Motif enrichment analysis:
motifEnrichmentTable_wGenes <- cisTarget(RcisT_geneLists, hg19_500bpUpstream_motifRanking_cispbOnly,
                               motifAnnot=motifAnnotations)

invisible(gc())
rm(hg19_500bpUpstream_motifRanking_cispbOnly)
showLogo(motifEnrichmentTable_wGenes)
```


